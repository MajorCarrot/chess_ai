package chess.help;

import java.util.ArrayList;
import java.util.List;

/**
 * Generates the list of moves for a given piece... A part of the AI
 *
 * @author Adithya
 */
public class movesForPiece {

    /**
     * The method generates the moves for a given original position and
     * boardState
     *
     * @param original the content of array from original position
     * @param parallelState the parallel board state generated by AI
     * @param movesDone the list with the movesDone till the board State is
     * achieved
     * @return the list containing all possible moves for the piece
     */
    public static List<String> moveMyPiece(final int original, final int[][] parallelState, final List<String> movesDone) {
        int[][] curState = parallelState;

        final int turn = original % 10;
        List<String> move = new ArrayList<>();
        switch (original / 10 % 10) {
            case 1:
                move = Bishop(curState, original, turn, movesDone);
                break;
            case 2: 
                move = King(curState, original, turn, movesDone);
                break;
            case 3:
                move = Knight(curState, original, turn, movesDone);
                break;
            case 4:
                move = Pawn(curState, original, turn, movesDone);
                break;
            case 5:
                move = Queen(curState, original, turn, movesDone);
                break;
            case 6:
                move = Rook(curState, original, turn, movesDone);
                break;
        }

        return helper.nullChanger(move);
    }

    private static List<String> Bishop(final int[][] curState, final int original, final int turn, final List<String> movesDone) {
        int finale;
        final int rowO = original / 1000 - 1;
        final int columnO = original / 100 % 10 - 1;
        List<String> movesValid = new ArrayList<>();
        boolean activeRU = true;//RightUp
        boolean activeRD = true;//RightDown
        boolean activeLU = true;//LeftUp
        boolean activeLD = true;//LeftDown

        for (int i = 1; activeRU || activeLU || activeRD || activeLD; i++) {

            if ((activeRU || activeLU) && rowO - i >= 0) {
                if (activeRU && columnO + i < 8) {
                    if (curState[rowO - i][columnO + i] % 100 != 2) {
                        activeRU = false;
                        if (curState[rowO - i][columnO + i] % 10 != original % 10) {
                            finale = curState[rowO - i][columnO + i];
                            String s = helper.IntToString(original * 10000 + finale);
                            if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                                if (moveValidator.checker(curState, original, finale)) {
                                    movesValid.add(s);
                                }
                            }
                        }
                    } else {
                        finale = (rowO - i + 1) * 1000 + (columnO + i + 1) * 100 + original % 100;
                        String s = helper.IntToString(original * 10000 + finale);
                        if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                            if (moveValidator.checker(curState, original, finale)) {
                                movesValid.add(s);
                            }
                        }
                    }
                } else {
                    activeRU = false;
                }

                if (activeLU && columnO - i >= 0) {
                    if (curState[rowO - i][columnO - i] % 100 != 2) {
                        activeLU = false;
                        if (curState[rowO - i][columnO - i] % 10 != original % 10) {
                            finale = curState[rowO - i][columnO - i];
                            String s = helper.IntToString(original * 10000 + finale);
                            if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                                if (moveValidator.checker(curState, original, finale)) {
                                    movesValid.add(s);
                                }
                            }
                        }
                    } else {
                        finale = (rowO - i + 1) * 1000 + (columnO - i + 1) * 100 + original % 100;
                        String s = helper.IntToString(original * 10000 + finale);
                        if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                            if (moveValidator.checker(curState, original, finale)) {
                                movesValid.add(s);
                            }
                        }
                    }
                } else {
                    activeLU = false;
                }
            } else {
                activeRU = false;
                activeLU = false;
            }

            if ((activeRD || activeLD) && rowO + i < 8) {
                if (activeRD && columnO + i < 8) {
                    if (curState[rowO + i][columnO + i] % 100 != 2) {
                        activeRD = false;
                        if (curState[rowO + i][columnO + i] % 10 != original % 10) {
                            finale = curState[rowO + i][columnO + i];
                            String s = helper.IntToString(original * 10000 + finale);
                            if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                                if (moveValidator.checker(curState, original, finale)) {
                                    movesValid.add(s);
                                }
                            }
                        }
                    } else {
                        finale = (rowO + i + 1) * 1000 + (columnO + i + 1) * 100 + original % 100;
                        String s = helper.IntToString(original * 10000 + finale);
                        if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                            if (moveValidator.checker(curState, original, finale)) {
                                movesValid.add(s);
                            }
                        }
                    }
                } else {
                    activeRD = false;
                }

                if (activeLD && columnO - i >= 0) {
                    if (curState[rowO + i][columnO - i] % 100 != 2) {
                        activeLD = false;
                        if (curState[rowO + i][columnO - i] % 10 != original % 10) {
                            finale = curState[rowO + i][columnO - i];
                            String s = helper.IntToString(original * 10000 + finale);
                            if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                                if (moveValidator.checker(curState, original, finale)) {
                                    movesValid.add(s);
                                }
                            }
                        }
                    } else {
                        finale = (rowO + i + 1) * 1000 + (columnO - i + 1) * 100 + original % 100;
                        String s = helper.IntToString(original * 10000 + finale);
                        if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                            if (moveValidator.checker(curState, original, finale)) {
                                movesValid.add(s);
                            }
                        }
                    }
                } else {
                    activeLD = false;
                }
            } else {
                activeRD = false;
                activeLD = false;
            }

        }
        return helper.nullChanger(movesValid);
    }

    private static List<String> King(final int[][] curState, final int original, final int turn, final List<String> movesDone) {
        final int rowO = original / 1000 - 1;
        final int columnO = original / 100 % 10 - 1;
        List<String> movesValid = new ArrayList<>();

        int finale;

        if (rowO + 1 < 8) {//down the board
            if (columnO + 1 < 8) {
                if (curState[rowO + 1][columnO + 1] % 10 != original % 10) {
                    finale = curState[rowO + 1][columnO + 1];
                    String s = helper.IntToString(original * 10000 + finale);
                    if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                        if (moveValidator.checker(curState, original, finale)) {
                            movesValid.add(s);
                        }
                    }
                }
            }

            if (curState[rowO + 1][columnO] % 10 != original % 10) {
                finale = curState[rowO + 1][columnO];
                String s = helper.IntToString(original * 10000 + finale);
                if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                    if (moveValidator.checker(curState, original, finale)) {
                        movesValid.add(s);
                    }
                }
            }

            if (columnO - 1 >= 0) {
                if (curState[rowO + 1][columnO - 1] % 10 != original % 10) {
                    finale = curState[rowO + 1][columnO - 1];
                    String s = helper.IntToString(original * 10000 + finale);
                    if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                        if (moveValidator.checker(curState, original, finale)) {
                            movesValid.add(s);
                        }
                    }
                }
            }

        }

        if (rowO - 1 >= 0) {//up the board
            if (columnO + 1 < 8) {
                if (curState[rowO - 1][columnO + 1] % 10 != original % 10) {
                    finale = curState[rowO - 1][columnO + 1];
                    String s = helper.IntToString(original * 10000 + finale);
                    if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                        if (moveValidator.checker(curState, original, finale)) {
                            movesValid.add(s);
                        }
                    }
                }
            }

            if (columnO - 1 >= 0) {
                if (curState[rowO - 1][columnO - 1] % 10 != original % 10) {
                    finale = curState[rowO - 1][columnO - 1];
                    String s = helper.IntToString(original * 10000 + finale);
                    if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                        if (moveValidator.checker(curState, original, finale)) {
                            movesValid.add(s);
                        }
                    }
                }
            }

            if (curState[rowO - 1][columnO] % 10 != original % 10) {
                finale = curState[rowO - 1][columnO];
                String s = helper.IntToString(original * 10000 + finale);
                if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                    if (moveValidator.checker(curState, original, finale)) {
                        movesValid.add(s);
                    }
                }
            }
        }

        if (columnO + 1 < 8) {//right along the row
            if (curState[rowO][columnO + 1] % 10 != original % 10) {
                finale = curState[rowO][columnO + 1];
                String s = helper.IntToString(original * 10000 + finale);
                if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                    if (moveValidator.checker(curState, original, finale)) {
                        movesValid.add(s);
                    }
                }
            }
        }

        if (columnO - 1 >= 0) {//left along row
            if (curState[rowO][columnO - 1] % 10 != original % 10) {
                finale = curState[rowO][columnO - 1];
                String s = helper.IntToString(original * 10000 + finale);
                if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                    if (moveValidator.checker(curState, original, finale)) {
                        movesValid.add(s);
                    }
                }
            }
        }

        return helper.nullChanger(movesValid);
    }

    private static List<String> Knight(final int[][] curState, final int original, final int turn, final List<String> movesDone) {
        final int rowO = original / 1000 - 1;
        final int columnO = original / 100 % 10 - 1;
        List<String> movesValid = new ArrayList<>();
        int finale;
        if (rowO + 1 < 8) {
            if (columnO + 2 < 8) {
                if (curState[rowO + 1][columnO + 2] % 10 != original % 10) {
                    finale = curState[rowO + 1][columnO + 2];
                    String s = helper.IntToString(original * 10000 + finale);
                    if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                        if (moveValidator.checker(curState, original, finale)) {
                            movesValid.add(s);
                        }
                    }
                }
            }

            if (columnO - 2 >= 0) {
                if (curState[rowO + 1][columnO - 2] % 10 != original % 10) {
                    finale = curState[rowO + 1][columnO - 2];
                    String s = helper.IntToString(original * 10000 + finale);
                    if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                        if (moveValidator.checker(curState, original, finale)) {
                            movesValid.add(s);
                        }
                    }
                }
            }
        }

        if (rowO - 1 >= 0) {
            if (columnO + 2 < 8) {
                if (curState[rowO - 1][columnO + 2] % 10 != original % 10) {
                    finale = curState[rowO - 1][columnO + 2];
                    String s = helper.IntToString(original * 10000 + finale);
                    if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                        if (moveValidator.checker(curState, original, finale)) {
                            movesValid.add(s);
                        }
                    }
                }
            }

            if (columnO - 2 >= 0) {
                if (curState[rowO - 1][columnO - 2] % 10 != original % 10) {
                    finale = curState[rowO - 1][columnO - 2];
                    String s = helper.IntToString(original * 10000 + finale);
                    if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                        if (moveValidator.checker(curState, original, finale)) {
                            movesValid.add(s);
                        }
                    }
                }
            }
        }

        if (rowO + 2 < 8) {
            if (columnO + 1 < 8) {
                if (curState[rowO + 2][columnO + 1] % 10 != original % 10) {
                    finale = curState[rowO + 2][columnO + 1];
                    String s = helper.IntToString(original * 10000 + finale);
                    if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                        if (moveValidator.checker(curState, original, finale)) {
                            movesValid.add(s);
                        }
                    }
                }
            }

            if (columnO - 1 >= 0) {
                if (curState[rowO + 2][columnO - 1] % 10 != original % 10) {
                    finale = curState[rowO + 2][columnO - 1];
                    String s = helper.IntToString(original * 10000 + finale);
                    if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                        if (moveValidator.checker(curState, original, finale)) {
                            movesValid.add(s);
                        }
                    }
                }
            }
        }

        if (rowO - 2 >= 0) {
            if (columnO + 1 < 8) {
                if (curState[rowO - 2][columnO + 1] % 10 != original % 10) {
                    finale = curState[rowO - 2][columnO + 1];
                    String s = helper.IntToString(original * 10000 + finale);
                    if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                        if (moveValidator.checker(curState, original, finale)) {
                            movesValid.add(s);
                        }
                    }
                }
            }
            if (columnO - 1 >= 0) {
                if (curState[rowO - 2][columnO - 1] % 10 != original % 10) {
                    finale = curState[rowO - 2][columnO - 1];
                    String s = helper.IntToString(original * 10000 + finale);
                    if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                        if (moveValidator.checker(curState, original, finale)) {
                            movesValid.add(s);
                        }
                    }
                }
            }
        }
        return helper.nullChanger(movesValid);
    }

    private static List<String> Pawn(final int[][] curState, final int original, final int turn, final List<String> movesDone) {
        final int rowO = original / 1000 - 1;
        final int columnO = original / 100 % 10 - 1;
        List<String> movesValid = new ArrayList<>();

        boolean originOrNot = false;
        switch (original) {
            case 2140:
            case 2240:
            case 2340:
            case 2440:
            case 2540:
            case 2640:
            case 2740:
            case 2840:
            case 7141:
            case 7241:
            case 7341:
            case 7441:
            case 7541:
            case 7641:
            case 7741:
            case 7841:
                originOrNot = true;
        }
        int finale;

        if (originOrNot && (rowO + 2 < 8 || rowO - 2 >= 0)) {
            if (rowO + 2 < 8) {
                if (original % 10 == 0 && curState[rowO + 1][columnO] % 100 == 2 && curState[rowO + 2][columnO] % 100 == 2) {
                    finale = curState[rowO + 2][columnO];
                    String s = helper.IntToString(original * 10000 + finale);
                    if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                        if (moveValidator.checker(curState, original, finale)) {
                            movesValid.add(s);
                        }
                    }
                }
            }

            if (rowO - 2 >= 0) {
                if (original % 10 == 1 && curState[rowO - 1][columnO] % 100 == 2 && curState[rowO - 2][columnO] % 100 == 2) {
                    finale = curState[rowO - 2][columnO];
                    String s = helper.IntToString(original * 10000 + finale);
                    if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                        if (moveValidator.checker(curState, original, finale)) {
                            movesValid.add(s);
                        }
                    }
                }
            }
        }

        if (rowO + 1 < 8) {
            if (original % 10 == 0 && curState[rowO + 1][columnO] % 100 == 2) {
                finale = curState[rowO + 1][columnO];
                String s = helper.IntToString(original * 10000 + finale);
                if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                    if (moveValidator.checker(curState, original, finale)) {
                        movesValid.add(s);
                    }
                }
            }
        }

        if (rowO - 1 >= 0) {
            if (original % 10 == 1 && curState[rowO - 1][columnO] % 100 == 2) {
                finale = curState[rowO - 1][columnO];
                String s = helper.IntToString(original * 10000 + finale);
                if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                    if (moveValidator.checker(curState, original, finale)) {
                        movesValid.add(s);
                    }
                }
            }
        }
        if (rowO + 1 < 8 && columnO + 1 < 8) {
            if (1 == curState[rowO + 1][columnO + 1] % 10 && original % 10 == 0) {
                finale = curState[rowO + 1][columnO + 1];
                String s = helper.IntToString(original * 10000 + finale);
                if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                    if (moveValidator.checker(curState, original, finale)) {
                        movesValid.add(s);
                    }
                }
            }
        }

        if (rowO + 1 < 8 && columnO - 1 >= 0) {
            if (curState[rowO + 1][columnO - 1] % 10 == 1 && original % 10 == 0)//checks one step diagonally to the leftDown for white
            {
                finale = curState[rowO + 1][columnO - 1];
                String s = helper.IntToString(original * 10000 + finale);
                if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                    if (moveValidator.checker(curState, original, finale)) {
                        movesValid.add(s);
                    }
                }
            }
        }

        if (rowO - 1 >= 0 && columnO + 1 < 8) {
            if (curState[rowO - 1][columnO + 1] % 10 == 0 && original % 10 == 1) {
                finale = curState[rowO - 1][columnO + 1];
                String s = helper.IntToString(original * 10000 + finale);
                if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                    if (moveValidator.checker(curState, original, finale)) {
                        movesValid.add(s);
                    }
                }
            }
        }

        if (rowO - 1 >= 0 && columnO - 1 >= 0) {
            if (curState[rowO - 1][columnO - 1] % 10 == 0 && original % 10 == 1) {
                finale = curState[rowO - 1][columnO - 1];
                String s = helper.IntToString(original * 10000 + finale);
                if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                    if (moveValidator.checker(curState, original, finale)) {
                        movesValid.add(s);
                    }
                }
            }
        }
        return helper.nullChanger(movesValid);
    }

    private static List<String> Queen(final int[][] curState, final int original, final int turn, final List<String> movesDone) {
        List<String> movesValid = new ArrayList<>();
        movesValid.addAll(Bishop(curState, original, turn, movesDone));
        movesValid.addAll(Rook(curState, original, turn, movesDone));

        return helper.nullChanger(movesValid);
    }

    private static List<String> Rook(final int[][] curState, final int original, final int turn, final List<String> movesDone) {
        int finale;
        final int rowO = original / 1000 - 1;
        final int columnO = original / 100 % 10 - 1;
        List<String> movesValid = new ArrayList<>();
        boolean activeR = true;//Right
        boolean activeD = true;//Down
        boolean activeU = true;//Up
        boolean activeL = true;//Left

        for (int i = 1; activeU || activeD || activeL || activeR; i++) {

            if (activeU || activeD) {
                if (activeU && rowO - i >= 0) {
                    finale = curState[rowO - i][columnO];
                    String s = helper.IntToString(original * 10000 + finale);
                    if (curState[rowO - i][columnO] % 100 != 2) {
                        activeU = false;
                        if (curState[rowO - i][columnO] % 10 != original % 10) {
                            if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                                if (moveValidator.checker(curState, original, finale)) {
                                    movesValid.add(s);
                                }
                            }
                        }
                    } else {
                        if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                            if (moveValidator.checker(curState, original, finale)) {
                                movesValid.add(s);
                            }
                        }
                    }
                } else {
                    activeU = false;
                }

                if (activeD && rowO + i < 8) {
                    finale = curState[rowO + i][columnO];
                    String s = helper.IntToString(original * 10000 + finale);
                    if (curState[rowO + i][columnO] % 100 != 2) {
                        activeD = false;
                        if (curState[rowO + i][columnO] % 10 != original % 10) {
                            if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                                if (moveValidator.checker(curState, original, finale)) {
                                    movesValid.add(s);
                                }
                            }
                        }
                    } else {
                        if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                            if (moveValidator.checker(curState, original, finale)) {
                                movesValid.add(s);
                            }
                        }
                    }
                } else {
                    activeD = false;
                }
            }
            if (activeR || activeL) {
                if (activeR && columnO + i < 8) {
                    finale = curState[rowO][columnO + i];
                    String s = helper.IntToString(original * 10000 + finale);
                    if (curState[rowO][columnO + i] % 100 != 2) {
                        activeR = false;
                        if (curState[rowO][columnO + i] % 10 != original % 10) {
                            if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                                if (moveValidator.checker(curState, original, finale)) {
                                    movesValid.add(s);
                                }
                            }
                        }
                    } else {
                        if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                            if (moveValidator.checker(curState, original, finale)) {
                                movesValid.add(s);
                            }
                        }
                    }
                } else {
                    activeR = false;
                }

                if (activeL && columnO - i >= 0) {
                    finale = curState[rowO][columnO - i];
                    String s = helper.IntToString(original * 10000 + finale);
                    if (curState[rowO][columnO - i] % 100 != 2) {
                        activeL = false;
                        if (curState[rowO][columnO - i] % 10 != original % 10) {
                            if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                                if (moveValidator.checker(curState, original, finale)) {
                                    movesValid.add(s);
                                }
                            }
                        }
                    } else {
                        if (!staleMate(original * 10000 + finale, turn, movesDone)) {
                            if (moveValidator.checker(curState, original, finale)) {
                                movesValid.add(s);
                            }
                        }
                    }
                } else {
                    activeL = false;
                }
            }
        }
        return helper.nullChanger(movesValid);
    }

    private static boolean staleMate(int n, int turn, final List<String> movesDone) {
        int[][] c = helper.setter();

        for (String move : movesDone) {
            int m = helper.StringToInt(c, move);
            int original = m / 10000;
            int finale = m % 10000;
            if(itemRemoved(finale) == 2)
                return false;
            c[original / 1000 - 1][original / 100 % 10 - 1] = original / 100 * 100 + 2;
            c[finale / 1000 - 1][finale / 100 % 10 - 1] = finale / 100 * 100 + original % 100;
        }

        final int original = n / 10000;
        final int finale = n % 10000;

        
        c[finale / 1000 - 1][finale / 100 % 10 - 1] = finale / 100 * 100 + original % 100;
        c[original / 1000 - 1][original / 100 % 10 - 1] = original / 100 * 100 + 2;
        boolean checkValidator = checks.checkChecker(c, (turn + 1) % 2);
        c[finale / 1000 - 1][finale / 100 % 10 - 1] = finale;
        c[original / 1000 - 1][original / 100 % 10 - 1] = original;

        return checkValidator;
       
    }

    private static int itemRemoved(int finale) {
        return finale / 10 % 10;
    }
}
